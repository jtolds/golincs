// AUTOGENERATED BY gopkg.in/spacemonkeygo/dbx.v0
// DO NOT EDIT.

package metadb

import (
	"database/sql"
	"fmt"
	"sync"
	"time"

	"github.com/jmoiron/sqlx"
	_ "github.com/mattn/go-sqlite3"
)

var WrapErr = func(err error) error { return err }
var Logger func(format string, args ...interface{})
var Now = time.Now

func loge(err error) {
	if Logger != nil && err != nil {
		Logger("error closing statement: %v", err)
	}
}

type Dimension struct {
	Name string `db:"name"`
	Idx  int64  `db:"idx"`
}
type Sample struct {
	Batch          sql.NullString `db:"batch"`
	CellId         sql.NullString `db:"cell_id"`
	PertDesc       sql.NullString `db:"pert_desc"`
	PertDose       sql.NullString `db:"pert_dose"`
	PertDoseUnit   sql.NullString `db:"pert_dose_unit"`
	PertId         sql.NullString `db:"pert_id"`
	PertTime       sql.NullString `db:"pert_time"`
	PertTimeUnit   sql.NullString `db:"pert_time_unit"`
	PertType       sql.NullString `db:"pert_type"`
	ReplicateCount sql.NullString `db:"replicate_count"`
	SigId          string         `db:"sig_id"`
}

type DB struct {
	*sqlx.DB
	lru  *lru
	impl implMethods
}

func Open(driver, source string, lru_size int) (*DB, error) {
	db, err := sqlx.Connect(driver, source)
	if err != nil {
		return nil, WrapErr(err)
	}

	lru := newLRU(db, lru_size)

	var impl implMethods
	switch driver {
	case "sqlite3":
		impl = &sqlite3DB{lru: lru}
	default:
		return nil, WrapErr(fmt.Errorf("unsupported driver %s", driver))
	}

	return &DB{
		DB:   db,
		lru:  lru,
		impl: impl,
	}, nil
}

func (obj *DB) Close() (err error) {
	obj.impl = nil
	obj.lru.Purge()
	return WrapErr(obj.DB.Close())
}

func (obj *DB) Schema() string {
	return obj.impl.schema()
}

func (obj *DB) DeleteAll() (total int64, err error) {
	if n, err := obj.impl.DeleteSamples(); err == nil {
		total += n
	} else {
		return total, WrapErr(err)
	}
	if n, err := obj.impl.DeleteDimensions(); err == nil {
		total += n
	} else {
		return total, WrapErr(err)
	}
	return total, nil
}

func (obj *DB) Open() (*Tx, error) {
	tx, err := obj.DB.Beginx()
	if err != nil {
		return nil, WrapErr(err)
	}

	return &Tx{Tx: tx, impl: obj.impl.begin(tx)}, nil
}

type Tx struct {
	*sqlx.Tx
	impl methods
}

func (tx *Tx) Commit() (err error) {
	tx.impl = nil
	return WrapErr(tx.Tx.Commit())
}

func (tx *Tx) Rollback() (err error) {
	tx.impl = nil
	return WrapErr(tx.Tx.Rollback())
}

func (tx *Tx) DeleteAll() (total int64, err error) {
	if n, err := tx.impl.DeleteSamples(); err == nil {
		total += n
	} else {
		return total, WrapErr(err)
	}
	if n, err := tx.impl.DeleteDimensions(); err == nil {
		total += n
	} else {
		return total, WrapErr(err)
	}
	return total, nil
}

type sqlite3DB struct {
	lru *lru
}

func (obj *sqlite3DB) schema() string {
	return `
CREATE TABLE dimensions (
	name text NOT NULL
,	idx integer NOT NULL
,	PRIMARY KEY (idx)
,	UNIQUE (name)
);

CREATE TABLE samples (
	batch text
,	cell_id text
,	pert_desc text
,	pert_dose text
,	pert_dose_unit text
,	pert_id text
,	pert_time text
,	pert_time_unit text
,	pert_type text
,	replicate_count text
,	sig_id text NOT NULL
,	PRIMARY KEY (sig_id)
);

`
}

func (obj *sqlite3DB) prepare(stmt string) (prepared *sqlx.Stmt, replace func(), err error) {
	entry, err := obj.lru.Get(stmt)
	if err != nil {
		return nil, nil, err
	}
	return entry.Stmt, func() { obj.lru.Replace(entry) }, nil
}

func (obj *sqlite3DB) logStmt(stmt string, args ...interface{}) {
	sqlite3LogStmt(stmt, args...)
}

func (obj *sqlite3DB) begin(tx *sqlx.Tx) methods {
	return &sqlite3Tx{
		tx:  tx,
		lru: obj.lru,
	}
}

type sqlite3Tx struct {
	tx  *sqlx.Tx
	lru *lru
}

func (obj *sqlite3Tx) prepare(stmt string) (prepared *sqlx.Stmt, replace func(), err error) {
	entry, err := obj.lru.Get(stmt)
	if err != nil {
		return nil, nil, err
	}
	return obj.tx.Stmtx(entry.Stmt), func() { obj.lru.Replace(entry) }, nil
}

func (obj *sqlite3Tx) logStmt(stmt string, args ...interface{}) {
	sqlite3LogStmt(stmt, args...)
}

func sqlite3LogStmt(stmt string, args ...interface{}) {
	// TODO: render placeholders
	if Logger != nil {
		Logger("sql:\n%s\nargs:\n%v", stmt, args)
	}
}

type entry struct {
	Stmt *sqlx.Stmt

	next, prev *entry
	key        string
	refs       int
}

type lru struct {
	mu       sync.Mutex
	db       *sqlx.DB
	capacity int
	root     entry
	index    map[string]*entry
}

// newLRU returns an initialized lru.
func newLRU(db *sqlx.DB, capacity int) *lru {
	l := &lru{
		db:       db,
		capacity: capacity,
		index:    make(map[string]*entry),
	}
	l.root.next = &l.root
	l.root.prev = &l.root
	return l
}

// insert inserts e after at, increments l.len.
func (l *lru) insert(e, at *entry) {
	n := at.next
	at.next = e
	e.prev = at
	e.next = n
	n.prev = e
}

// remove removes e from its list, decrements l.len
func (l *lru) remove(e *entry) {
	e.prev.next = e.next
	e.next.prev = e.prev
	e.next = nil // avoid memory leaks
	e.prev = nil // avoid memory leaks
}

func (l *lru) evict(capacity int) {
	if capacity < 0 {
		return
	}

	to_evict := len(l.index) - capacity
	current := &l.root
	for i := 0; i < to_evict; i++ {
		current = current.prev
		if current == &l.root {
			panic("index out of whack. race conditions?")
		}
		if current.refs > 0 {
			continue
		}
		// whoa boy is this subtle. l.remove blows away current.next and
		// current.prev. but current.next.prev will be mutated to be
		// current.prev for the next iteration!
		next_current := current.next

		l.remove(current)
		delete(l.index, current.key)
		loge(current.Stmt.Close())

		current = next_current
	}
}

func (l *lru) Get(key string) (*entry, error) {
	l.mu.Lock()
	defer l.mu.Unlock()

	e, ok := l.index[key]
	if ok {
		l.remove(e)
		l.insert(e, &l.root)
		e.refs++

		return e, nil
	}

	stmt, err := l.db.Preparex(l.db.Rebind(key))
	if err != nil {
		return nil, WrapErr(err)
	}

	e = &entry{
		Stmt: stmt,
		key:  key,
	}
	l.insert(e, &l.root)
	l.index[key] = e
	e.refs++

	return e, nil
}

func (l *lru) Replace(e *entry) {
	l.mu.Lock()
	defer l.mu.Unlock()

	e.refs--
	l.evict(l.capacity)
}

func (l *lru) Purge() {
	l.mu.Lock()
	defer l.mu.Unlock()

	l.evict(0)
}

func (obj *DB) CreateDimension(
	dimension_name string,
	dimension_idx int64) (
	result *Dimension, err error) {
	return obj.impl.CreateDimension(dimension_name, dimension_idx)
}

func (obj *Tx) CreateDimension(
	dimension_name string,
	dimension_idx int64) (
	result *Dimension, err error) {
	return obj.impl.CreateDimension(dimension_name, dimension_idx)
}

func (obj *DB) CreateRawDimension(
	dimension_name string,
	dimension_idx int64) (
	result *Dimension, err error) {
	return obj.impl.CreateRawDimension(dimension_name, dimension_idx)
}

func (obj *Tx) CreateRawDimension(
	dimension_name string,
	dimension_idx int64) (
	result *Dimension, err error) {
	return obj.impl.CreateRawDimension(dimension_name, dimension_idx)
}

func (obj *sqlite3DB) CreateDimension(
	dimension_name string,
	dimension_idx int64) (
	result *Dimension, err error) {

	const stmt = `INSERT INTO dimensions(name, idx) VALUES(?, ?)`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, dimension_name, dimension_idx)

	res, err := prepared.Exec(dimension_name, dimension_idx)
	if err != nil {
		return nil, WrapErr(err)
	}

	pk, err := res.LastInsertId()
	if err != nil {
		return nil, WrapErr(err)
	}
	return obj.GetDimensionByIdx(pk)
}

func (obj *sqlite3Tx) CreateDimension(
	dimension_name string,
	dimension_idx int64) (
	result *Dimension, err error) {

	const stmt = `INSERT INTO dimensions(name, idx) VALUES(?, ?)`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, dimension_name, dimension_idx)

	res, err := prepared.Exec(dimension_name, dimension_idx)
	if err != nil {
		return nil, WrapErr(err)
	}

	pk, err := res.LastInsertId()
	if err != nil {
		return nil, WrapErr(err)
	}
	return obj.GetDimensionByIdx(pk)
}

func (obj *sqlite3DB) CreateRawDimension(
	dimension_name string,
	dimension_idx int64) (
	result *Dimension, err error) {
	const stmt = `INSERT INTO dimensions(name, idx) VALUES(?, ?)`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, dimension_name, dimension_idx)

	res, err := prepared.Exec(dimension_name, dimension_idx)
	if err != nil {
		return nil, WrapErr(err)
	}

	pk, err := res.LastInsertId()
	if err != nil {
		return nil, WrapErr(err)
	}
	return obj.GetDimensionByIdx(pk)
}

func (obj *sqlite3Tx) CreateRawDimension(
	dimension_name string,
	dimension_idx int64) (
	result *Dimension, err error) {
	const stmt = `INSERT INTO dimensions(name, idx) VALUES(?, ?)`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, dimension_name, dimension_idx)

	res, err := prepared.Exec(dimension_name, dimension_idx)
	if err != nil {
		return nil, WrapErr(err)
	}

	pk, err := res.LastInsertId()
	if err != nil {
		return nil, WrapErr(err)
	}
	return obj.GetDimensionByIdx(pk)
}

func (obj *DB) GetDimensions() (
	result []*Dimension, err error) {
	return obj.impl.GetDimensions()
}

func (obj *Tx) GetDimensions() (
	result []*Dimension, err error) {
	return obj.impl.GetDimensions()
}

func (obj *sqlite3DB) GetDimensions() (
	result []*Dimension, err error) {

	const stmt = `SELECT dimensions.* FROM dimensions`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt)

	err = prepared.Select(&result)
	if err != nil {
		return nil, WrapErr(err)
	}
	return result, nil
}

func (obj *sqlite3Tx) GetDimensions() (
	result []*Dimension, err error) {

	const stmt = `SELECT dimensions.* FROM dimensions`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt)

	err = prepared.Select(&result)
	if err != nil {
		return nil, WrapErr(err)
	}
	return result, nil
}

func (obj *DB) CountDimension() (
	result int, err error) {
	return obj.impl.CountDimension()
}

func (obj *Tx) CountDimension() (
	result int, err error) {
	return obj.impl.CountDimension()
}

func (obj *DB) HasDimension() (
	result bool, err error) {
	return obj.impl.HasDimension()
}

func (obj *Tx) HasDimension() (
	result bool, err error) {
	return obj.impl.HasDimension()
}

func (obj *sqlite3DB) CountDimension() (
	result int, err error) {

	const stmt = `SELECT count(*) FROM dimensions`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt)

	err = prepared.QueryRowx().Scan(&result)
	if err != nil {
		return 0, WrapErr(err)
	}
	return result, nil
}

func (obj *sqlite3Tx) CountDimension() (
	result int, err error) {

	const stmt = `SELECT count(*) FROM dimensions`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt)

	err = prepared.QueryRowx().Scan(&result)
	if err != nil {
		return 0, WrapErr(err)
	}
	return result, nil
}

func (obj *sqlite3DB) HasDimension() (
	result bool, err error) {
	count, err := obj.CountDimension()
	if err != nil {
		return false, err
	}
	return count > 0, nil
}

func (obj *sqlite3Tx) HasDimension() (
	result bool, err error) {
	count, err := obj.CountDimension()
	if err != nil {
		return false, err
	}
	return count > 0, nil
}

func (obj *DB) PagedGetDimensions(
	ctoken string, limit int) (
	result []*Dimension, ctokenout string, err error) {
	return obj.impl.PagedGetDimensions(ctoken, limit)
}

func (obj *Tx) PagedGetDimensions(
	ctoken string, limit int) (
	result []*Dimension, ctokenout string, err error) {
	return obj.impl.PagedGetDimensions(ctoken, limit)
}

func (obj *sqlite3DB) PagedGetDimensions(
	ctoken string, limit int) (
	result []*Dimension, ctokenout string, err error) {

	const stmt = `SELECT dimensions.* FROM dimensions
		WHERE dimensions.idx > ?
		ORDER BY dimensions.idx ASC
		LIMIT ?`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt)

	if ctoken == "" {
		ctoken = "0"
	}

	err = prepared.Select(&result, ctoken, limit)
	if err != nil {
		return nil, "", WrapErr(err)
	}

	if len(result) == limit {
		ctokenout = fmt.Sprint(result[limit-1].Idx)
	}

	return result, ctokenout, nil
}

func (obj *sqlite3Tx) PagedGetDimensions(
	ctoken string, limit int) (
	result []*Dimension, ctokenout string, err error) {

	const stmt = `SELECT dimensions.* FROM dimensions
		WHERE dimensions.idx > ?
		ORDER BY dimensions.idx ASC
		LIMIT ?`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt)

	if ctoken == "" {
		ctoken = "0"
	}

	err = prepared.Select(&result, ctoken, limit)
	if err != nil {
		return nil, "", WrapErr(err)
	}

	if len(result) == limit {
		ctokenout = fmt.Sprint(result[limit-1].Idx)
	}

	return result, ctokenout, nil
}

func (obj *DB) DeleteDimensions() (
	count int64, err error) {
	return obj.impl.DeleteDimensions()
}

func (obj *Tx) DeleteDimensions() (
	count int64, err error) {
	return obj.impl.DeleteDimensions()
}

func (obj *sqlite3DB) DeleteDimensions() (
	count int64, err error) {

	const stmt = `DELETE FROM dimensions`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt)

	res, err := prepared.Exec()
	if err != nil {
		return 0, WrapErr(err)
	}
	count, err = res.RowsAffected()
	if err != nil {
		return 0, WrapErr(err)
	}
	return count, nil
}

func (obj *sqlite3Tx) DeleteDimensions() (
	count int64, err error) {

	const stmt = `DELETE FROM dimensions`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt)

	res, err := prepared.Exec()
	if err != nil {
		return 0, WrapErr(err)
	}
	count, err = res.RowsAffected()
	if err != nil {
		return 0, WrapErr(err)
	}
	return count, nil
}

func (obj *DB) GetDimensionByIdx(
	dimension_idx int64) (
	result *Dimension, err error) {
	return obj.impl.GetDimensionByIdx(dimension_idx)
}

func (obj *Tx) GetDimensionByIdx(
	dimension_idx int64) (
	result *Dimension, err error) {
	return obj.impl.GetDimensionByIdx(dimension_idx)
}

func (obj *sqlite3DB) GetDimensionByIdx(
	dimension_idx int64) (
	result *Dimension, err error) {

	const stmt = `SELECT dimensions.* FROM dimensions
		WHERE dimensions.idx = ?`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, dimension_idx)

	result = &Dimension{}
	err = prepared.QueryRowx(dimension_idx).StructScan(result)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, WrapErr(err)
	}
	return result, nil
}

func (obj *sqlite3Tx) GetDimensionByIdx(
	dimension_idx int64) (
	result *Dimension, err error) {

	const stmt = `SELECT dimensions.* FROM dimensions
		WHERE dimensions.idx = ?`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, dimension_idx)

	result = &Dimension{}
	err = prepared.QueryRowx(dimension_idx).StructScan(result)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, WrapErr(err)
	}
	return result, nil
}

func (obj *DB) CountDimensionByIdx(
	dimension_idx int64) (
	result int, err error) {
	return obj.impl.CountDimensionByIdx(dimension_idx)
}

func (obj *Tx) CountDimensionByIdx(
	dimension_idx int64) (
	result int, err error) {
	return obj.impl.CountDimensionByIdx(dimension_idx)
}

func (obj *DB) HasDimensionByIdx(
	dimension_idx int64) (
	result bool, err error) {
	return obj.impl.HasDimensionByIdx(dimension_idx)
}

func (obj *Tx) HasDimensionByIdx(
	dimension_idx int64) (
	result bool, err error) {
	return obj.impl.HasDimensionByIdx(dimension_idx)
}

func (obj *sqlite3DB) CountDimensionByIdx(
	dimension_idx int64) (
	result int, err error) {

	const stmt = `SELECT count(*) FROM dimensions
		WHERE dimensions.idx = ?`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, dimension_idx)

	err = prepared.QueryRowx(dimension_idx).Scan(&result)
	if err != nil {
		return 0, WrapErr(err)
	}
	return result, nil
}

func (obj *sqlite3Tx) CountDimensionByIdx(
	dimension_idx int64) (
	result int, err error) {

	const stmt = `SELECT count(*) FROM dimensions
		WHERE dimensions.idx = ?`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, dimension_idx)

	err = prepared.QueryRowx(dimension_idx).Scan(&result)
	if err != nil {
		return 0, WrapErr(err)
	}
	return result, nil
}

func (obj *sqlite3DB) HasDimensionByIdx(
	dimension_idx int64) (
	result bool, err error) {
	count, err := obj.CountDimensionByIdx(dimension_idx)
	if err != nil {
		return false, err
	}
	return count > 0, nil
}

func (obj *sqlite3Tx) HasDimensionByIdx(
	dimension_idx int64) (
	result bool, err error) {
	count, err := obj.CountDimensionByIdx(dimension_idx)
	if err != nil {
		return false, err
	}
	return count > 0, nil
}

func (obj *DB) DeleteDimensionByIdx(
	dimension_idx int64) (
	deleted bool, err error) {
	return obj.impl.DeleteDimensionByIdx(dimension_idx)
}

func (obj *Tx) DeleteDimensionByIdx(
	dimension_idx int64) (
	deleted bool, err error) {
	return obj.impl.DeleteDimensionByIdx(dimension_idx)
}

func (obj *sqlite3DB) DeleteDimensionByIdx(
	dimension_idx int64) (
	deleted bool, err error) {

	const stmt = `DELETE FROM dimensions
		WHERE dimensions.idx = ?`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, dimension_idx)

	res, err := prepared.Exec(dimension_idx)
	if err != nil {
		return false, WrapErr(err)
	}
	count, err := res.RowsAffected()
	if err != nil {
		return false, WrapErr(err)
	}
	return count > 0, nil
}

func (obj *sqlite3Tx) DeleteDimensionByIdx(
	dimension_idx int64) (
	deleted bool, err error) {

	const stmt = `DELETE FROM dimensions
		WHERE dimensions.idx = ?`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, dimension_idx)

	res, err := prepared.Exec(dimension_idx)
	if err != nil {
		return false, WrapErr(err)
	}
	count, err := res.RowsAffected()
	if err != nil {
		return false, WrapErr(err)
	}
	return count > 0, nil
}

func (obj *DB) CreateSample(
	sample_batch sql.NullString,
	sample_cell_id sql.NullString,
	sample_pert_desc sql.NullString,
	sample_pert_dose sql.NullString,
	sample_pert_dose_unit sql.NullString,
	sample_pert_id sql.NullString,
	sample_pert_time sql.NullString,
	sample_pert_time_unit sql.NullString,
	sample_pert_type sql.NullString,
	sample_replicate_count sql.NullString,
	sample_sig_id string) (
	result *Sample, err error) {
	return obj.impl.CreateSample(sample_batch, sample_cell_id, sample_pert_desc, sample_pert_dose, sample_pert_dose_unit, sample_pert_id, sample_pert_time, sample_pert_time_unit, sample_pert_type, sample_replicate_count, sample_sig_id)
}

func (obj *Tx) CreateSample(
	sample_batch sql.NullString,
	sample_cell_id sql.NullString,
	sample_pert_desc sql.NullString,
	sample_pert_dose sql.NullString,
	sample_pert_dose_unit sql.NullString,
	sample_pert_id sql.NullString,
	sample_pert_time sql.NullString,
	sample_pert_time_unit sql.NullString,
	sample_pert_type sql.NullString,
	sample_replicate_count sql.NullString,
	sample_sig_id string) (
	result *Sample, err error) {
	return obj.impl.CreateSample(sample_batch, sample_cell_id, sample_pert_desc, sample_pert_dose, sample_pert_dose_unit, sample_pert_id, sample_pert_time, sample_pert_time_unit, sample_pert_type, sample_replicate_count, sample_sig_id)
}

func (obj *DB) CreateRawSample(
	sample_batch sql.NullString,
	sample_cell_id sql.NullString,
	sample_pert_desc sql.NullString,
	sample_pert_dose sql.NullString,
	sample_pert_dose_unit sql.NullString,
	sample_pert_id sql.NullString,
	sample_pert_time sql.NullString,
	sample_pert_time_unit sql.NullString,
	sample_pert_type sql.NullString,
	sample_replicate_count sql.NullString,
	sample_sig_id string) (
	result *Sample, err error) {
	return obj.impl.CreateRawSample(sample_batch, sample_cell_id, sample_pert_desc, sample_pert_dose, sample_pert_dose_unit, sample_pert_id, sample_pert_time, sample_pert_time_unit, sample_pert_type, sample_replicate_count, sample_sig_id)
}

func (obj *Tx) CreateRawSample(
	sample_batch sql.NullString,
	sample_cell_id sql.NullString,
	sample_pert_desc sql.NullString,
	sample_pert_dose sql.NullString,
	sample_pert_dose_unit sql.NullString,
	sample_pert_id sql.NullString,
	sample_pert_time sql.NullString,
	sample_pert_time_unit sql.NullString,
	sample_pert_type sql.NullString,
	sample_replicate_count sql.NullString,
	sample_sig_id string) (
	result *Sample, err error) {
	return obj.impl.CreateRawSample(sample_batch, sample_cell_id, sample_pert_desc, sample_pert_dose, sample_pert_dose_unit, sample_pert_id, sample_pert_time, sample_pert_time_unit, sample_pert_type, sample_replicate_count, sample_sig_id)
}

func (obj *sqlite3DB) CreateSample(
	sample_batch sql.NullString,
	sample_cell_id sql.NullString,
	sample_pert_desc sql.NullString,
	sample_pert_dose sql.NullString,
	sample_pert_dose_unit sql.NullString,
	sample_pert_id sql.NullString,
	sample_pert_time sql.NullString,
	sample_pert_time_unit sql.NullString,
	sample_pert_type sql.NullString,
	sample_replicate_count sql.NullString,
	sample_sig_id string) (
	result *Sample, err error) {

	const stmt = `INSERT INTO samples(batch, cell_id, pert_desc, pert_dose, pert_dose_unit, pert_id, pert_time, pert_time_unit, pert_type, replicate_count, sig_id) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, sample_batch, sample_cell_id, sample_pert_desc, sample_pert_dose, sample_pert_dose_unit, sample_pert_id, sample_pert_time, sample_pert_time_unit, sample_pert_type, sample_replicate_count, sample_sig_id)

	res, err := prepared.Exec(sample_batch, sample_cell_id, sample_pert_desc, sample_pert_dose, sample_pert_dose_unit, sample_pert_id, sample_pert_time, sample_pert_time_unit, sample_pert_type, sample_replicate_count, sample_sig_id)
	if err != nil {
		return nil, WrapErr(err)
	}

	_ = res
	return obj.GetSampleBySigId(sample_sig_id)
}

func (obj *sqlite3Tx) CreateSample(
	sample_batch sql.NullString,
	sample_cell_id sql.NullString,
	sample_pert_desc sql.NullString,
	sample_pert_dose sql.NullString,
	sample_pert_dose_unit sql.NullString,
	sample_pert_id sql.NullString,
	sample_pert_time sql.NullString,
	sample_pert_time_unit sql.NullString,
	sample_pert_type sql.NullString,
	sample_replicate_count sql.NullString,
	sample_sig_id string) (
	result *Sample, err error) {

	const stmt = `INSERT INTO samples(batch, cell_id, pert_desc, pert_dose, pert_dose_unit, pert_id, pert_time, pert_time_unit, pert_type, replicate_count, sig_id) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, sample_batch, sample_cell_id, sample_pert_desc, sample_pert_dose, sample_pert_dose_unit, sample_pert_id, sample_pert_time, sample_pert_time_unit, sample_pert_type, sample_replicate_count, sample_sig_id)

	res, err := prepared.Exec(sample_batch, sample_cell_id, sample_pert_desc, sample_pert_dose, sample_pert_dose_unit, sample_pert_id, sample_pert_time, sample_pert_time_unit, sample_pert_type, sample_replicate_count, sample_sig_id)
	if err != nil {
		return nil, WrapErr(err)
	}

	_ = res
	return obj.GetSampleBySigId(sample_sig_id)
}

func (obj *sqlite3DB) CreateRawSample(
	sample_batch sql.NullString,
	sample_cell_id sql.NullString,
	sample_pert_desc sql.NullString,
	sample_pert_dose sql.NullString,
	sample_pert_dose_unit sql.NullString,
	sample_pert_id sql.NullString,
	sample_pert_time sql.NullString,
	sample_pert_time_unit sql.NullString,
	sample_pert_type sql.NullString,
	sample_replicate_count sql.NullString,
	sample_sig_id string) (
	result *Sample, err error) {
	const stmt = `INSERT INTO samples(batch, cell_id, pert_desc, pert_dose, pert_dose_unit, pert_id, pert_time, pert_time_unit, pert_type, replicate_count, sig_id) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, sample_batch, sample_cell_id, sample_pert_desc, sample_pert_dose, sample_pert_dose_unit, sample_pert_id, sample_pert_time, sample_pert_time_unit, sample_pert_type, sample_replicate_count, sample_sig_id)

	res, err := prepared.Exec(sample_batch, sample_cell_id, sample_pert_desc, sample_pert_dose, sample_pert_dose_unit, sample_pert_id, sample_pert_time, sample_pert_time_unit, sample_pert_type, sample_replicate_count, sample_sig_id)
	if err != nil {
		return nil, WrapErr(err)
	}

	_ = res
	return obj.GetSampleBySigId(sample_sig_id)
}

func (obj *sqlite3Tx) CreateRawSample(
	sample_batch sql.NullString,
	sample_cell_id sql.NullString,
	sample_pert_desc sql.NullString,
	sample_pert_dose sql.NullString,
	sample_pert_dose_unit sql.NullString,
	sample_pert_id sql.NullString,
	sample_pert_time sql.NullString,
	sample_pert_time_unit sql.NullString,
	sample_pert_type sql.NullString,
	sample_replicate_count sql.NullString,
	sample_sig_id string) (
	result *Sample, err error) {
	const stmt = `INSERT INTO samples(batch, cell_id, pert_desc, pert_dose, pert_dose_unit, pert_id, pert_time, pert_time_unit, pert_type, replicate_count, sig_id) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, sample_batch, sample_cell_id, sample_pert_desc, sample_pert_dose, sample_pert_dose_unit, sample_pert_id, sample_pert_time, sample_pert_time_unit, sample_pert_type, sample_replicate_count, sample_sig_id)

	res, err := prepared.Exec(sample_batch, sample_cell_id, sample_pert_desc, sample_pert_dose, sample_pert_dose_unit, sample_pert_id, sample_pert_time, sample_pert_time_unit, sample_pert_type, sample_replicate_count, sample_sig_id)
	if err != nil {
		return nil, WrapErr(err)
	}

	_ = res
	return obj.GetSampleBySigId(sample_sig_id)
}

func (obj *DB) GetSamples() (
	result []*Sample, err error) {
	return obj.impl.GetSamples()
}

func (obj *Tx) GetSamples() (
	result []*Sample, err error) {
	return obj.impl.GetSamples()
}

func (obj *sqlite3DB) GetSamples() (
	result []*Sample, err error) {

	const stmt = `SELECT samples.* FROM samples`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt)

	err = prepared.Select(&result)
	if err != nil {
		return nil, WrapErr(err)
	}
	return result, nil
}

func (obj *sqlite3Tx) GetSamples() (
	result []*Sample, err error) {

	const stmt = `SELECT samples.* FROM samples`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt)

	err = prepared.Select(&result)
	if err != nil {
		return nil, WrapErr(err)
	}
	return result, nil
}

func (obj *DB) CountSample() (
	result int, err error) {
	return obj.impl.CountSample()
}

func (obj *Tx) CountSample() (
	result int, err error) {
	return obj.impl.CountSample()
}

func (obj *DB) HasSample() (
	result bool, err error) {
	return obj.impl.HasSample()
}

func (obj *Tx) HasSample() (
	result bool, err error) {
	return obj.impl.HasSample()
}

func (obj *sqlite3DB) CountSample() (
	result int, err error) {

	const stmt = `SELECT count(*) FROM samples`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt)

	err = prepared.QueryRowx().Scan(&result)
	if err != nil {
		return 0, WrapErr(err)
	}
	return result, nil
}

func (obj *sqlite3Tx) CountSample() (
	result int, err error) {

	const stmt = `SELECT count(*) FROM samples`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt)

	err = prepared.QueryRowx().Scan(&result)
	if err != nil {
		return 0, WrapErr(err)
	}
	return result, nil
}

func (obj *sqlite3DB) HasSample() (
	result bool, err error) {
	count, err := obj.CountSample()
	if err != nil {
		return false, err
	}
	return count > 0, nil
}

func (obj *sqlite3Tx) HasSample() (
	result bool, err error) {
	count, err := obj.CountSample()
	if err != nil {
		return false, err
	}
	return count > 0, nil
}

func (obj *DB) PagedGetSamples(
	ctoken string, limit int) (
	result []*Sample, ctokenout string, err error) {
	return obj.impl.PagedGetSamples(ctoken, limit)
}

func (obj *Tx) PagedGetSamples(
	ctoken string, limit int) (
	result []*Sample, ctokenout string, err error) {
	return obj.impl.PagedGetSamples(ctoken, limit)
}

func (obj *sqlite3DB) PagedGetSamples(
	ctoken string, limit int) (
	result []*Sample, ctokenout string, err error) {

	const stmt = `SELECT samples.* FROM samples
		WHERE samples.sig_id > ?
		ORDER BY samples.sig_id ASC
		LIMIT ?`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt)

	if ctoken == "" {
		ctoken = "0"
	}

	err = prepared.Select(&result, ctoken, limit)
	if err != nil {
		return nil, "", WrapErr(err)
	}

	if len(result) == limit {
		ctokenout = fmt.Sprint(result[limit-1].SigId)
	}

	return result, ctokenout, nil
}

func (obj *sqlite3Tx) PagedGetSamples(
	ctoken string, limit int) (
	result []*Sample, ctokenout string, err error) {

	const stmt = `SELECT samples.* FROM samples
		WHERE samples.sig_id > ?
		ORDER BY samples.sig_id ASC
		LIMIT ?`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt)

	if ctoken == "" {
		ctoken = "0"
	}

	err = prepared.Select(&result, ctoken, limit)
	if err != nil {
		return nil, "", WrapErr(err)
	}

	if len(result) == limit {
		ctokenout = fmt.Sprint(result[limit-1].SigId)
	}

	return result, ctokenout, nil
}

func (obj *DB) DeleteSamples() (
	count int64, err error) {
	return obj.impl.DeleteSamples()
}

func (obj *Tx) DeleteSamples() (
	count int64, err error) {
	return obj.impl.DeleteSamples()
}

func (obj *sqlite3DB) DeleteSamples() (
	count int64, err error) {

	const stmt = `DELETE FROM samples`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt)

	res, err := prepared.Exec()
	if err != nil {
		return 0, WrapErr(err)
	}
	count, err = res.RowsAffected()
	if err != nil {
		return 0, WrapErr(err)
	}
	return count, nil
}

func (obj *sqlite3Tx) DeleteSamples() (
	count int64, err error) {

	const stmt = `DELETE FROM samples`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt)

	res, err := prepared.Exec()
	if err != nil {
		return 0, WrapErr(err)
	}
	count, err = res.RowsAffected()
	if err != nil {
		return 0, WrapErr(err)
	}
	return count, nil
}

func (obj *DB) GetSampleBySigId(
	sample_sig_id string) (
	result *Sample, err error) {
	return obj.impl.GetSampleBySigId(sample_sig_id)
}

func (obj *Tx) GetSampleBySigId(
	sample_sig_id string) (
	result *Sample, err error) {
	return obj.impl.GetSampleBySigId(sample_sig_id)
}

func (obj *sqlite3DB) GetSampleBySigId(
	sample_sig_id string) (
	result *Sample, err error) {

	const stmt = `SELECT samples.* FROM samples
		WHERE samples.sig_id = ?`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, sample_sig_id)

	result = &Sample{}
	err = prepared.QueryRowx(sample_sig_id).StructScan(result)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, WrapErr(err)
	}
	return result, nil
}

func (obj *sqlite3Tx) GetSampleBySigId(
	sample_sig_id string) (
	result *Sample, err error) {

	const stmt = `SELECT samples.* FROM samples
		WHERE samples.sig_id = ?`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, sample_sig_id)

	result = &Sample{}
	err = prepared.QueryRowx(sample_sig_id).StructScan(result)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, WrapErr(err)
	}
	return result, nil
}

func (obj *DB) CountSampleBySigId(
	sample_sig_id string) (
	result int, err error) {
	return obj.impl.CountSampleBySigId(sample_sig_id)
}

func (obj *Tx) CountSampleBySigId(
	sample_sig_id string) (
	result int, err error) {
	return obj.impl.CountSampleBySigId(sample_sig_id)
}

func (obj *DB) HasSampleBySigId(
	sample_sig_id string) (
	result bool, err error) {
	return obj.impl.HasSampleBySigId(sample_sig_id)
}

func (obj *Tx) HasSampleBySigId(
	sample_sig_id string) (
	result bool, err error) {
	return obj.impl.HasSampleBySigId(sample_sig_id)
}

func (obj *sqlite3DB) CountSampleBySigId(
	sample_sig_id string) (
	result int, err error) {

	const stmt = `SELECT count(*) FROM samples
		WHERE samples.sig_id = ?`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, sample_sig_id)

	err = prepared.QueryRowx(sample_sig_id).Scan(&result)
	if err != nil {
		return 0, WrapErr(err)
	}
	return result, nil
}

func (obj *sqlite3Tx) CountSampleBySigId(
	sample_sig_id string) (
	result int, err error) {

	const stmt = `SELECT count(*) FROM samples
		WHERE samples.sig_id = ?`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, sample_sig_id)

	err = prepared.QueryRowx(sample_sig_id).Scan(&result)
	if err != nil {
		return 0, WrapErr(err)
	}
	return result, nil
}

func (obj *sqlite3DB) HasSampleBySigId(
	sample_sig_id string) (
	result bool, err error) {
	count, err := obj.CountSampleBySigId(sample_sig_id)
	if err != nil {
		return false, err
	}
	return count > 0, nil
}

func (obj *sqlite3Tx) HasSampleBySigId(
	sample_sig_id string) (
	result bool, err error) {
	count, err := obj.CountSampleBySigId(sample_sig_id)
	if err != nil {
		return false, err
	}
	return count > 0, nil
}

func (obj *DB) DeleteSampleBySigId(
	sample_sig_id string) (
	deleted bool, err error) {
	return obj.impl.DeleteSampleBySigId(sample_sig_id)
}

func (obj *Tx) DeleteSampleBySigId(
	sample_sig_id string) (
	deleted bool, err error) {
	return obj.impl.DeleteSampleBySigId(sample_sig_id)
}

func (obj *sqlite3DB) DeleteSampleBySigId(
	sample_sig_id string) (
	deleted bool, err error) {

	const stmt = `DELETE FROM samples
		WHERE samples.sig_id = ?`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, sample_sig_id)

	res, err := prepared.Exec(sample_sig_id)
	if err != nil {
		return false, WrapErr(err)
	}
	count, err := res.RowsAffected()
	if err != nil {
		return false, WrapErr(err)
	}
	return count > 0, nil
}

func (obj *sqlite3Tx) DeleteSampleBySigId(
	sample_sig_id string) (
	deleted bool, err error) {

	const stmt = `DELETE FROM samples
		WHERE samples.sig_id = ?`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, sample_sig_id)

	res, err := prepared.Exec(sample_sig_id)
	if err != nil {
		return false, WrapErr(err)
	}
	count, err := res.RowsAffected()
	if err != nil {
		return false, WrapErr(err)
	}
	return count > 0, nil
}

func (obj *DB) GetDimensionByName(
	dimension_name string) (
	result *Dimension, err error) {
	return obj.impl.GetDimensionByName(dimension_name)
}

func (obj *Tx) GetDimensionByName(
	dimension_name string) (
	result *Dimension, err error) {
	return obj.impl.GetDimensionByName(dimension_name)
}

func (obj *sqlite3DB) GetDimensionByName(
	dimension_name string) (
	result *Dimension, err error) {

	const stmt = `SELECT dimensions.* FROM dimensions
		WHERE dimensions.name = ?`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, dimension_name)

	result = &Dimension{}
	err = prepared.QueryRowx(dimension_name).StructScan(result)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, WrapErr(err)
	}
	return result, nil
}

func (obj *sqlite3Tx) GetDimensionByName(
	dimension_name string) (
	result *Dimension, err error) {

	const stmt = `SELECT dimensions.* FROM dimensions
		WHERE dimensions.name = ?`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, dimension_name)

	result = &Dimension{}
	err = prepared.QueryRowx(dimension_name).StructScan(result)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, WrapErr(err)
	}
	return result, nil
}

func (obj *DB) CountDimensionByName(
	dimension_name string) (
	result int, err error) {
	return obj.impl.CountDimensionByName(dimension_name)
}

func (obj *Tx) CountDimensionByName(
	dimension_name string) (
	result int, err error) {
	return obj.impl.CountDimensionByName(dimension_name)
}

func (obj *DB) HasDimensionByName(
	dimension_name string) (
	result bool, err error) {
	return obj.impl.HasDimensionByName(dimension_name)
}

func (obj *Tx) HasDimensionByName(
	dimension_name string) (
	result bool, err error) {
	return obj.impl.HasDimensionByName(dimension_name)
}

func (obj *sqlite3DB) CountDimensionByName(
	dimension_name string) (
	result int, err error) {

	const stmt = `SELECT count(*) FROM dimensions
		WHERE dimensions.name = ?`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, dimension_name)

	err = prepared.QueryRowx(dimension_name).Scan(&result)
	if err != nil {
		return 0, WrapErr(err)
	}
	return result, nil
}

func (obj *sqlite3Tx) CountDimensionByName(
	dimension_name string) (
	result int, err error) {

	const stmt = `SELECT count(*) FROM dimensions
		WHERE dimensions.name = ?`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, dimension_name)

	err = prepared.QueryRowx(dimension_name).Scan(&result)
	if err != nil {
		return 0, WrapErr(err)
	}
	return result, nil
}

func (obj *sqlite3DB) HasDimensionByName(
	dimension_name string) (
	result bool, err error) {
	count, err := obj.CountDimensionByName(dimension_name)
	if err != nil {
		return false, err
	}
	return count > 0, nil
}

func (obj *sqlite3Tx) HasDimensionByName(
	dimension_name string) (
	result bool, err error) {
	count, err := obj.CountDimensionByName(dimension_name)
	if err != nil {
		return false, err
	}
	return count > 0, nil
}

func (obj *DB) DeleteDimensionByName(
	dimension_name string) (
	deleted bool, err error) {
	return obj.impl.DeleteDimensionByName(dimension_name)
}

func (obj *Tx) DeleteDimensionByName(
	dimension_name string) (
	deleted bool, err error) {
	return obj.impl.DeleteDimensionByName(dimension_name)
}

func (obj *sqlite3DB) DeleteDimensionByName(
	dimension_name string) (
	deleted bool, err error) {

	const stmt = `DELETE FROM dimensions
		WHERE dimensions.name = ?`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, dimension_name)

	res, err := prepared.Exec(dimension_name)
	if err != nil {
		return false, WrapErr(err)
	}
	count, err := res.RowsAffected()
	if err != nil {
		return false, WrapErr(err)
	}
	return count > 0, nil
}

func (obj *sqlite3Tx) DeleteDimensionByName(
	dimension_name string) (
	deleted bool, err error) {

	const stmt = `DELETE FROM dimensions
		WHERE dimensions.name = ?`
	prepared, replace, err := obj.prepare(stmt)
	if err != nil {
		err = WrapErr(err)
		return
	}
	defer replace()
	obj.logStmt(stmt, dimension_name)

	res, err := prepared.Exec(dimension_name)
	if err != nil {
		return false, WrapErr(err)
	}
	count, err := res.RowsAffected()
	if err != nil {
		return false, WrapErr(err)
	}
	return count > 0, nil
}

type methods interface {
	CreateDimension(
		dimension_name string,
		dimension_idx int64) (
		result *Dimension, err error)

	CreateRawDimension(
		dimension_name string,
		dimension_idx int64) (
		result *Dimension, err error)

	GetDimensions() (
		result []*Dimension, err error)

	CountDimension() (
		result int, err error)

	HasDimension() (
		result bool, err error)

	PagedGetDimensions(
		ctoken string, limit int) (
		result []*Dimension, ctokenout string, err error)

	DeleteDimensions() (
		count int64, err error)

	GetDimensionByIdx(
		dimension_idx int64) (
		result *Dimension, err error)

	CountDimensionByIdx(
		dimension_idx int64) (
		result int, err error)

	HasDimensionByIdx(
		dimension_idx int64) (
		result bool, err error)

	DeleteDimensionByIdx(
		dimension_idx int64) (
		deleted bool, err error)

	CreateSample(
		sample_batch sql.NullString,
		sample_cell_id sql.NullString,
		sample_pert_desc sql.NullString,
		sample_pert_dose sql.NullString,
		sample_pert_dose_unit sql.NullString,
		sample_pert_id sql.NullString,
		sample_pert_time sql.NullString,
		sample_pert_time_unit sql.NullString,
		sample_pert_type sql.NullString,
		sample_replicate_count sql.NullString,
		sample_sig_id string) (
		result *Sample, err error)

	CreateRawSample(
		sample_batch sql.NullString,
		sample_cell_id sql.NullString,
		sample_pert_desc sql.NullString,
		sample_pert_dose sql.NullString,
		sample_pert_dose_unit sql.NullString,
		sample_pert_id sql.NullString,
		sample_pert_time sql.NullString,
		sample_pert_time_unit sql.NullString,
		sample_pert_type sql.NullString,
		sample_replicate_count sql.NullString,
		sample_sig_id string) (
		result *Sample, err error)

	GetSamples() (
		result []*Sample, err error)

	CountSample() (
		result int, err error)

	HasSample() (
		result bool, err error)

	PagedGetSamples(
		ctoken string, limit int) (
		result []*Sample, ctokenout string, err error)

	DeleteSamples() (
		count int64, err error)

	GetSampleBySigId(
		sample_sig_id string) (
		result *Sample, err error)

	CountSampleBySigId(
		sample_sig_id string) (
		result int, err error)

	HasSampleBySigId(
		sample_sig_id string) (
		result bool, err error)

	DeleteSampleBySigId(
		sample_sig_id string) (
		deleted bool, err error)

	GetDimensionByName(
		dimension_name string) (
		result *Dimension, err error)

	CountDimensionByName(
		dimension_name string) (
		result int, err error)

	HasDimensionByName(
		dimension_name string) (
		result bool, err error)

	DeleteDimensionByName(
		dimension_name string) (
		deleted bool, err error)
}

type implMethods interface {
	begin(tx *sqlx.Tx) methods
	schema() string
	methods
}
